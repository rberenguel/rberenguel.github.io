<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>mostlymaths.net  | How does the &#39;in&#39; keyword work in Python?</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.57.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    
      <link rel="stylesheet" href="/byrne-caps/stylesheet.css">
    
      <link rel="stylesheet" href="/css/custom.css">
    

    
      
    

    

    <meta property="og:title" content="How does the &#39;in&#39; keyword work in Python?" />
<meta property="og:description" content="A subtitle to this post could be More yak shaving
A few days go I played a bit with a naive implementation of Bloom filters in Python. I wanted to time them against just checking whether a field is in a set/collection. I found something slightly puzzling: it looked like in worked too fast for smaller lists. And I wondered: maybe small lists are special internally, and allow for really fast lookups?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/2018/04/how-does-in-keyword-work-in-python.html/" />
<meta property="article:published_time" content="2018-04-15T22:11:00+02:00" />
<meta property="article:modified_time" content="2018-04-15T22:11:00+02:00" />
<meta itemprop="name" content="How does the &#39;in&#39; keyword work in Python?">
<meta itemprop="description" content="A subtitle to this post could be More yak shaving
A few days go I played a bit with a naive implementation of Bloom filters in Python. I wanted to time them against just checking whether a field is in a set/collection. I found something slightly puzzling: it looked like in worked too fast for smaller lists. And I wondered: maybe small lists are special internally, and allow for really fast lookups?">


<meta itemprop="datePublished" content="2018-04-15T22:11:00&#43;02:00" />
<meta itemprop="dateModified" content="2018-04-15T22:11:00&#43;02:00" />
<meta itemprop="wordCount" content="938">



<meta itemprop="keywords" content="Python,C,github," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How does the &#39;in&#39; keyword work in Python?"/>
<meta name="twitter:description" content="A subtitle to this post could be More yak shaving
A few days go I played a bit with a naive implementation of Bloom filters in Python. I wanted to time them against just checking whether a field is in a set/collection. I found something slightly puzzling: it looked like in worked too fast for smaller lists. And I wondered: maybe small lists are special internally, and allow for really fast lookups?"/>

  </head>

  <body class="ma0 helvetica bg-near-white">

    



  <header>
    <div class="bg-gray">
      <nav class="pv1 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="" class="f3 fw2 hover-white no-underline white-90 dib">
      mostlymaths.net
    </a>
    <div class="flex-l items-center">
      

      
      











    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      

  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <h1 class="fw1 mb1 f1">How does the &#39;in&#39; keyword work in Python?</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2018-04-15T22:11:00&#43;02:00">April 15, 2018</time>
      
      
      &nbsp;&nbsp;&nbsp;
      <span class="fw1 mv4 dib tracked i" style="font-size: 0.4rem;"> 5 minutes read</span>
      <span class="fw1 mv4 dib tracked i" style="font-size: 0.4rem;"> | 938 words</span>
      
    </header>
    
    <section class="nested-copy-line-height lh-copy f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l justify "><p>A subtitle to this post could be <em>More yak shaving</em></p>

<p>A few days go I played a bit with a naive implementation of Bloom filters in Python. I wanted to time them against just checking whether a field is in a set/collection. I found something slightly puzzling: it looked like <code>in</code> worked <em>too fast</em> for smaller lists. And I wondered: maybe small lists are special internally, and allow for really fast lookups? Maybe they have some internal index? This raised the question: how does <code>in</code> find stuff <em>in</em> sequences?</p>

<p>Instead of reading the documentation I delved into the <a href="https://github.com/python/cpython">cpython</a> source. Skipping the documentation was a bad idea, since it is not only pretty comprehensive but explains everything&hellip; if you know what you are looking for. But a dive into this big pile of C was more fun. I was also stupid enough to not Google the answer until I was editing this post&hellip; <a href="https://stackoverflow.com/a/12244378">This excellent Stack Overflow answer</a> covers more or less what I explain here.</p>

<p>The <code>in</code> keyword (defined <a href="https://github.com/python/cpython/blob/master/Python/graminit.c#L2195">here</a>) is actually a shorthand for running <code>__contains__</code> from the target object, you probably know this already. Your class will be able to provide <code>in</code> if you add this magic method, you can read about this in the first chapter of <a href="https://amzn.to/2GEEZct">Fluent Python</a>. But tracing this inside <code>cpython</code> is a bit cumbersome and got me diving into interesting pieces of the code. By the way, how the Python compiler works is documented <a href="https://devguide.python.org/compiler/">here</a>.</p>

<p>First, after we have parsed the code and generated a parse tree from our text, we go to the abstract syntax tree. Converting the string <code>in</code> as part of some node of Python source in this tree into <em>an</em> <code>In</code> <a href="https://github.com/python/cpython/blob/master/Python/ast.c#L1163">here</a>:</p>

<p>And now, what does actually <code>In</code> do? Well, we need to move forward in the compilation chain, and check <a href="https://github.com/python/cpython/blob/a95d98607efe0c43475b354543e49bf8e240bc6f/Python/compile.c#L2185">compile.c</a>:</p>

<p>This is inside a function called <code>cmpop</code>, which is called when we find the <code>COMPARE_OP</code> opcode. This is the opcode we’d see by disassembling anything running <code>in</code> or <code>==</code> or any other comparison operator (all comparison operators are in the same basket, see <a href="https://github.com/python/cpython/blob/702f8f3611bc49b73772cce2b9b041bd11ff9b35/Include/opcode.h#L139">here</a>). We can follow the route through <a href="https://github.com/python/cpython/blob/d8b291a74284307610946f1b5801aa95d7f1e052/Python/ceval.c#L4685">ceval.c</a> now:</p>

<p>So, we are calling this <code>PySequence_Contains</code> thingy. A bit more grep and we can find it defined in <a href="https://github.com/python/cpython/blob/f320be77ffb73e3b9e7fc98c37b8df3975d84b40/Objects/abstract.c#L2037">abstract.c</a>:</p>

<p>And now we can see what it does:</p>

<ol>
<li>Get a pointer to the sequence’s base sequence methods in the C struct slot <code>tp_as_sequence</code></li>
<li>If there is a <code>sq_contains</code> method pointer there, invoke it and return</li>
<li>Otherwise, use iterative search</li>
</ol>

<p>But hey, where is my <code>__contains__</code>? The magic happens on new object/class/type definition: <a href="https://github.com/python/cpython/blob/c3d9508ff22ece9a96892b628dd5813e2fb0cd80/Objects/typeobject.c#L4711">typeobject.c</a> The base object all classes extend from looks like the following struct (from <a href="https://github.com/python/cpython/blob/a5552f023e1d8cbafee1e51d316cc581deb2295f/Include/object.h#L346">object.h</a>):</p>

<p>This means that, technically, all objects have a field in their defining struct for sequences: <code>tp_as_sequence</code>. This is populated when we define a new class (which internally is known as <em>type</em>) in <a href="https://github.com/python/cpython/blob/c3d9508ff22ece9a96892b628dd5813e2fb0cd80/Objects/typeobject.c#L2602">typeobject.c</a>. Slots <a href="https://github.com/python/cpython/blob/c3d9508ff22ece9a96892b628dd5813e2fb0cd80/Objects/typeobject.c#L2515">are populated from what is essentially a dictionary of methods</a> by invoking <a href="https://www.blogger.com/blogger.g?blogID=13497321">fixup_slot_dispatchers</a>. This maps the python name <code>__contains__</code> to the corresponding slot in the struct, <code>sq_contains</code> and defines which function sets it up, <a href="https://github.com/python/cpython/blob/c3d9508ff22ece9a96892b628dd5813e2fb0cd80/Objects/typeobject.c#L6098">slot_sq_contains</a>:</p>

<p>Built-in objects (and likely libraries with C extensions) implement these directly in C, and point its slot to the C method:</p>

<p>Finally, this method looks for a method defined in the class and called <code>__contains__</code>. If it is <code>None</code> (that is, it is defined and is <code>None</code>), object is not a container, that’s it. If it is <em>not defined</em> (hence the null, and this one is actually puzzling&hellip; reduces to it not being provided when defining the class&hellip; I think), Python falls back to iterating for search using <code>__iter__</code> (which is what eventually gets called under <code>PySequence_IterSearch</code>). If this is also not valid or available, an error returns, following a chain of -1 in the method lookups.</p>

<p>If you have been paying attention you’ll see that we are actually deferring to iterative search in two places: when defining the slot in <code>sq_contains</code> but also when invoking <code>PySequence_Contains</code>. I’m not 100% sure about why this is the case, and experimenting with the REPL does not get you very far, since you can never be sure if you are hitting <code>PySequence_Contains -&gt; PY_ITERSEARCH_CONTAINS</code> or <code>PySequence_Contains -&gt; sq_contains -&gt; PY_ITERSEARCH_CONTAINS</code> without changing the messages (and I don’t feel like recompiling <code>Cpython</code>). Weirdly, the second case should be faster since it is going straight for the method via the slot without needing an extra method lookup.</p>

<p>As expected, dictionary lookup is fancier. It is a common and known performance improvement in Python to change lists or other sequence-like datatypes for dictionaries, since they show the best performance for most operations. Since internally in Python everything from methods/functions to classes is implemented in one way or another as dictionaries (or reusing the machinery that is built for dictionaries), anything that speeds dictionaries up, speeds the whole of Python code. Of <em>course</em>, dictionary lookup is <em>usually</em> fast no matter the language: hash table lookup in general (leaving aside how collision resolution might be implemented in lookup) is O(1) fast. Note that below we have the macro: <code>#define PyUnicode_CheckExact(op) (Py_TYPE(op) == &amp;PyUnicode_Type)</code></p>

<p>There even is a specialised method for cases when the hash key is known (not sure of the use case, since magic methods are hardcoded in the object structs, maybe it’s used to optimise tighter loops?).</p>

<p>And if you wonder how <code>key in dict</code> works, it is of course by introducing the method in the struct for sequences. The snippet below is from <code>dictobject.c</code>, as the methods above.</p>

<p>And here finishes my exploration of <code>cpython</code> to figure out how <code>in</code> contains. Not sure about you, but I had a lot of fun.</p>
<hr/><ul class="pa0">
  
   <li class="list" style="display:inline;">
     <a href="/tags/python" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Python</a>
   </li>
  
   <li class="list" style="display:inline;">
     <a href="/tags/c" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">C</a>
   </li>
  
   <li class="list" style="display:inline;">
     <a href="/tags/github" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">github</a>
   </li>
  
</ul>
<div class="mt6">
            
            
        </div>
    </section>
<aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links rounded-6">
    <p class="fw1 f4 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/2018/01/2017-year-in-review.html/">2017: Year in Review</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2016/12/2016-in-review.html/">2016 in Review</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2013/04/just-as-mario-using-plan9-plumber.html/">Just as Mario: Using the Plan9 plumber utility</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2012/09/using-git-and-setting-remote-git-server.html/">Version Control: Started using git and github (and how to set-up a remote git server)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2012/06/timeline-of-whatlanguageiscom-first.html/">Timeline of whatlanguageis.com: first Django project</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-gray bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="" >
    &copy; 2019 mostlymaths.net
  </a>
    <div>










</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
