---
title: 'Learning Forth by working on a raytracer'
date: 2010-03-03T22:30:00.010+01:00
draft: false
tags : [Programming, Linux, Forth]
---

[![](http://1.bp.blogspot.com/_f3d3llNlZKQ/S47WWIaA8ZI/AAAAAAAAB6Y/bleAwvOH4LY/s400/038e793509a0637d002f7110.L.jpg)](http://www.amazon.com/Forth-Atari-Learning-Ekkehard-Floegel/dp/0936200383)After following a [twitter feed](http://twitter.com/programmingfeed) about programming, I got overwhelmed by [FORTH](http://en.wikipedia.org/wiki/Forth_%28programming_language%29) related posts. I had already read something about forth before (stack-based, somewhat fast, good for embedded devices), but so many bit.ly links pointing to webs of implementations of FORTH and FORTH things made me decide to, well, take a [deeper look](http://berenguel.blogspot.com/2010/03/forths-create-does-maybe-im-amazed.html).  
  
Looks like a nice language, having something I enjoy about [Lisp](http://berenguel.blogspot.com/2009/08/lavaurs-algorithm.html) (interactivity) and something I like about [PostScript](http://berenguel.blogspot.com/2008/12/quick-postscript-programming-tutorial.html) (stack based). Thus... time for real learning.  
  
I have been thoroughly thinking about "What". You can't learn a programming language per-se, you need a project to work on.  
  
I shuffled several things (besides implementing my own Forth in my HP49G... still don't know how to do it, and know too little Saturn Assembly... Someday!) and finally decided to make a new instance of my (unfinished) [Lisp raytracer](http://berenguel.blogspot.com/2009/06/lisp-raytracing-again.html), in Forth. It will be quite a lengthy feat (will take at least 3 months, as I knew Lisp when I started that), but I hope it ends working and thus makes me happy and "forthy". For now, I have just one function, to calculate the euclidean norm of a 3-vector with components in the (floating point) stack:

> : norm3 ( X Y Z -- X Y Z R, returns norm of X, Y, Z on stack )  
> fover \\ X Y Z Y  
> 3 fpick \\ X Y Z Y X  
> 2 fpick \\ X Y Z Y X Z  
> fdup f\* fswap \\ X Y Z Y Z^2 X  
> fdup f\* frot \\ X Y Z Z^2 X^2 Y  
> fdup f\* f+ f+ \\ X Y Z Z^2+X^2+Y^2  
> fsqrt ;

Probably is not the best implementation (I still have a tendency to [C](http://en.wikipedia.org/wiki/C_%28programming_language%29)\-ify things when stack-working), if someone around here knows a better way to do this, please drop me a line. By the way, the header image was found in [](http://www.amazon.com/Forth-Atari-Learning-Ekkehard-Floegel/dp/0936200383)[Amazon](http://www.amazon.com/Forth-Atari-Learning-Ekkehard-Floegel/dp/0936200383?ie=UTF8&tag=rbersblog-20&link_code=btl&camp=213689&creative=392969)![](http://www.assoc-amazon.com/e/ir?t=rbersblog-20&l=btl&camp=213689&creative=392969&o=1&a=0936200383)... Strange cover for a programming book!  
  
You can also check progress in this post, [FORTH's "CREATE .. DOES>" Maybe I'm amazed?](http://berenguel.blogspot.com/2010/03/forths-create-does-maybe-im-amazed.html) where I discuss what has been labelled "the jewel of FORTH", the "CREATE .. DOES>" structure.  
  
You may also like  
ParseList(ScrambleList(Relateds(Forth, Programming, Lisp)),15)
