<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on mostlymaths.net</title>
    <link>https://mostlymaths.net/tags/c/</link>
    <description>Recent content in C on mostlymaths.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 15 Apr 2018 22:11:00 +0200</lastBuildDate>
    
	<atom:link href="https://mostlymaths.net/tags/c/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How does the &#39;in&#39; keyword work in Python?</title>
      <link>https://mostlymaths.net/2018/04/how-does-in-keyword-work-in-python.html/</link>
      <pubDate>Sun, 15 Apr 2018 22:11:00 +0200</pubDate>
      
      <guid>https://mostlymaths.net/2018/04/how-does-in-keyword-work-in-python.html/</guid>
      <description>&lt;p&gt;A few days go I played a bit with a naive implementation of &lt;a href=&#34;https://en.wikipedia.org/wiki/Bloom_filter&#34;&gt;Bloom
filters&lt;/a&gt; in Python. I wanted to time
them against just checking whether a field is in a set/collection. I found
something slightly puzzling: it looked like the &lt;code&gt;in&lt;/code&gt; worked &lt;em&gt;too fast&lt;/em&gt; for
smaller lists. And I wondered: maybe small lists are special internally, and
allow for really fast lookups? Maybe they have some internal index? This raised
the question: how does &lt;code&gt;in&lt;/code&gt; find stuff &lt;em&gt;in&lt;/em&gt; sequences?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Abstract triangles in LISP</title>
      <link>https://mostlymaths.net/2009/12/abstract-triangles-in-lisp.html/</link>
      <pubDate>Wed, 02 Dec 2009 00:01:00 +0100</pubDate>
      
      <guid>https://mostlymaths.net/2009/12/abstract-triangles-in-lisp.html/</guid>
      <description> A LISP random triangle generator. Also wrote a C version.
  </description>
    </item>
    
  </channel>
</rss>